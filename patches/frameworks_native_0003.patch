From 6092130bab4da78a2171464cf9b21b95000cbf80 Mon Sep 17 00:00:00 2001
From: ErwinP <erwin.pannecoucke@gmail.com>
Date: Mon, 6 Aug 2012 01:40:23 +0200
Subject: [PATCH] Support screenshot / renderScreenToTexture under OpenGL ES
 1.0

Original author: Won-Kyu Park
Port back from CM9 /w whitespace trail and LOGD > ALOGD usage fix

current implemented screenshot / renderScreenToTexture() of
SurfaceFlinger use FrameBuffer Object(FBO) in the OpenGL ES 1.1/2.0
extention

directly use framebuffer device /dev/graphics/fb0 to emulate FBO.

Change-Id: Icff6bf015321d6e442b91968e29fc65338065acf
---
 services/surfaceflinger/SurfaceFlinger.cpp |  140 +++++++++++++++++++++++++++-
 services/surfaceflinger/SurfaceFlinger.h   |    7 ++
 2 files changed, 145 insertions(+), 2 deletions(-)

diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index 7f83d6f..75aa211 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -26,6 +26,7 @@
 #include <limits.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <linux/fb.h>
 #include <sys/ioctl.h>
 
 #include <cutils/log.h>
@@ -105,7 +106,7 @@ SurfaceFlinger::SurfaceFlinger()
 {
     init();
 #ifdef BOARD_USES_SAMSUNG_HDMI
-    LOGD(">>> Run service");
+    ALOGD(">>> Run service");
     android::SecTVOutService::instantiate();
 #ifdef SAMSUNG_EXYNOS5250
     mHdmiClient = SecHdmiClient::getInstance();
@@ -1846,7 +1847,7 @@ status_t SurfaceFlinger::renderScreenToTextureLocked(DisplayID dpy,
     ATRACE_CALL();
 
     if (!GLExtensions::getInstance().haveFramebufferObject())
-        return INVALID_OPERATION;
+        return directRenderScreenToTextureLocked(dpy, textureName, uOut, vOut);
 
     // get screen geometry
     const DisplayHardware& hw(graphicPlane(dpy).displayHardware());
@@ -1906,6 +1907,141 @@ status_t SurfaceFlinger::renderScreenToTextureLocked(DisplayID dpy,
     return NO_ERROR;
 }
 
+
+status_t SurfaceFlinger::directRenderScreenToTextureLocked(DisplayID dpy,
+        GLuint* textureName, GLfloat* uOut, GLfloat* vOut)
+{
+    status_t result;
+    const DisplayHardware& hw(graphicPlane(dpy).displayHardware());
+
+    // use device framebuffer in /dev/graphics/fb0
+    size_t offset;
+    uint32_t bytespp, format, gl_format, gl_type;
+    size_t size = 0;
+    struct fb_var_screeninfo vinfo;
+    const char* fbpath = "/dev/graphics/fb0";
+    int fb = open(fbpath, O_RDONLY);
+    void const* mapbase = MAP_FAILED;
+    ssize_t mapsize = -1;
+
+    if (fb < 0) {
+        ALOGE("Failed to open framebuffer");
+        return INVALID_OPERATION;
+    }
+
+    if (ioctl(fb, FBIOGET_VSCREENINFO, &vinfo) < 0) {
+        ALOGE("Failed to get framebuffer info");
+        close(fb);
+        return INVALID_OPERATION;
+    }
+
+    bytespp = vinfo.bits_per_pixel / 8;
+    const uint32_t hw_w = vinfo.xres;
+    const uint32_t hw_h = vinfo.yres;
+    switch (bytespp) {
+    case 2:
+        format = PIXEL_FORMAT_RGB_565;
+        gl_format = GL_RGB;
+        gl_type = GL_UNSIGNED_SHORT_5_6_5;
+        break;
+    case 4:
+        format = PIXEL_FORMAT_RGBX_8888;
+        gl_format = GL_RGBA;
+        gl_type = GL_UNSIGNED_BYTE;
+        break;
+    default:
+        close(fb);
+        LOGE("Failed to detect framebuffer bytespp");
+        return INVALID_OPERATION;
+        break;
+    }
+    offset = (vinfo.xoffset + vinfo.yoffset * vinfo.xres) * bytespp;
+    size = vinfo.xres * vinfo.yres * bytespp;
+
+    mapsize = offset + size;
+    mapbase = mmap(0, mapsize, PROT_READ, MAP_PRIVATE, fb, 0);
+    close(fb);
+    if (mapbase == MAP_FAILED) {
+       return INVALID_OPERATION;
+    }
+
+    void const* fbbase = (void *)((char const *)mapbase + offset);
+    GLfloat u = 1;
+    GLfloat v = 1;
+
+    // build texture
+    GLuint tname;
+    glGenTextures(1, &tname);
+    glBindTexture(GL_TEXTURE_2D, tname);
+    glTexImage2D(GL_TEXTURE_2D, 0, gl_format,
+            hw_w, hw_h, 0, gl_format, GL_UNSIGNED_BYTE, 0);
+    if (glGetError() != GL_NO_ERROR) {
+        while ( glGetError() != GL_NO_ERROR ) ;
+        GLint tw = (2 << (31 - clz(hw_w)));
+        GLint th = (2 << (31 - clz(hw_h)));
+        glTexImage2D(GL_TEXTURE_2D, 0, gl_format,
+                tw, th, 0, gl_format, GL_UNSIGNED_BYTE, 0);
+        u = GLfloat(hw_w) / tw;
+        v = GLfloat(hw_h) / th;
+    }
+
+    // write fb data to image buffer texture (reverse order)
+    GLubyte* imageData = (GLubyte*)malloc(size);
+   if (imageData) {
+        void *ptr = imageData;
+        uint32_t rowlen = hw_w * bytespp;
+        offset = size;
+        for (uint32_t j = hw_h; j > 0; j--) {
+            offset -= rowlen;
+            memcpy(ptr, fbbase + offset, rowlen);
+            ptr += rowlen;
+        }
+
+        // write image buffer to the texture
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+
+        // copy imageData to the texture
+        glTexImage2D(GL_TEXTURE_2D, 0, gl_format, hw_w, hw_h, 0,
+                gl_format, gl_type, imageData);
+
+        ALOGI("direct Framebuffer texture for gl_format=%d gl_type=%d", gl_format, gl_type);
+        result = NO_ERROR;
+    } else {
+        result = NO_MEMORY;
+    }
+
+    // redraw the screen entirely...
+    glDisable(GL_TEXTURE_2D);
+    glDisable(GL_SCISSOR_TEST);
+    glClearColor(0,0,0,1);
+    glClear(GL_COLOR_BUFFER_BIT);
+    glEnable(GL_SCISSOR_TEST);
+    glMatrixMode(GL_MODELVIEW);
+    glLoadIdentity();
+    const Vector< sp<LayerBase> >& layers(mVisibleLayersSortedByZ);
+    const size_t count = layers.size();
+    for (size_t i=0 ; i<count ; ++i) {
+        const sp<LayerBase>& layer(layers[i]);
+        layer->drawForSreenShot();
+    }
+
+    hw.compositionComplete();
+
+    // done
+    munmap((void *)mapbase, mapsize);
+
+    *textureName = tname;
+    *uOut = u;
+    *vOut = v;
+    // free buffer memory
+    if (imageData) {
+        free(imageData);
+    }
+
+    return result;
+}
+
 // ---------------------------------------------------------------------------
 
 class VSyncWaiter {
diff --git a/services/surfaceflinger/SurfaceFlinger.h b/services/surfaceflinger/SurfaceFlinger.h
index 3bd49d9..8fd808b 100644
--- a/services/surfaceflinger/SurfaceFlinger.h
+++ b/services/surfaceflinger/SurfaceFlinger.h
@@ -350,6 +350,13 @@ private:
                     uint32_t reqWidth, uint32_t reqHeight,
                     uint32_t minLayerZ, uint32_t maxLayerZ);
 
+           status_t directCaptureScreenImplLocked(DisplayID dpy,
+                    sp<IMemoryHeap>* heap,
+                    uint32_t* width, uint32_t* height, PixelFormat* format,
+                    uint32_t reqWidth, uint32_t reqHeight,
+                    uint32_t minLayerZ, uint32_t maxLayerZ);
+                    status_t directRenderScreenToTextureLocked(DisplayID dpy,
+
             status_t turnElectronBeamOffImplLocked(int32_t mode);
             status_t turnElectronBeamOnImplLocked(int32_t mode);
             status_t electronBeamOffAnimationImplLocked();
-- 
1.7.9.5

